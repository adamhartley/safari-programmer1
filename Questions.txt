Q1) Which are valid?

a) doStuff() {
     var x; // NO, must initialize right here...
   }
b) class Y {
     var x = 99; // NO, only "local" vars
   }
c) doStuff() {
     var y = 99; // YES :)
   }
d) doStuff() {
     var var = 99; // YES!!!! var is a pseudo-type, not keyword... (backward compatibility)
   }

Q2) Given:
class X {
    static int MAX_VAL = 100;
    int value = 99;
    public void setVal(int x) {
      if (x <= MAX_VAL) value = x;
    }
  }
and:
    X a = new X();
    X b = new X();
    a.setVal(120);
    System.out.print(a.value + ", ");
    b.MAX_VAL = 150;
    a.setVal(140);
    System.out.println(a.value);

What is the result?
    A) 99, 99
    B) 120, 140
    C) 99, 140
    D) Compilation failure
    E) Exception at runtime
     */
  }

Q3) Given:
 class Y {
    static String sayHi() { return "Y-Hello"; }
    String sayHi2() { return "Y-Hello2"; }
  }
  class Z extends Y {
    static String sayHi() { return "Z-Hello"; }
    String sayHi2() { return "Z-Hello2"; }
  }
and:
    Y y = new Z();
    System.out.println(y.sayHi() + ", " +y.sayHi2());

What is the result?
    A) Y-Hello, Y-Hello2
    B) Y-Hello, Z-Hello2
    C) Z-Hello, Z-Hello2
    D) Z-Hello, Y-Hello2
    E) Compilation fails

Q4) Given:
 class Y {
    static String sayHi() { return "Y-Hello"; }
    String sayHi2() { return "Y-Hello2"; }
  }
  class Z extends Y {
    static String sayHi() { return "Z-Hello"; }
    String sayHi2() { return "Z-Hello2"; }
  }
and:
    System.out.println(Z.sayHi() + ", " + Y.sayHi2());

What is the result?
    A) Y-Hello, Y-Hello2
    B) Y-Hello, Z-Hello2
    C) Z-Hello, Z-Hello2
    D) Z-Hello, Y-Hello2
    E) Compilation fails

Q5) Given:
 class Y {
    int y = 99;
    static String sayHi() { return "Y-Hello "; }
  }
  class Z extends Y {
    int y = 100;
    static String sayHi() { return "Z-Hello " + new Z().y; }
  }
and:
    Z z = new Z();
    System.out.println(Y.sayHi() + ", " + z.sayHi());

What is the result?
    A) Y-Hello, Y-Hello
    B) Y-Hello, Z-Hello 99
    C) Y-Hello, Z-Hello 100
    D) Z-Hello 99, Z-Hello 100
    E) Compilation fails


Q6) Given:
  class Base {
    void doBaseStuff() { System.out.println("doBaseStuff"); }
  }

class Sub extends Base {
    void doBaseStuff() { System.out.println("doSubStuff"); }
    void doOtherStuff() { System.out.println("doOtherStuff"); }
  }

    Base b = new Sub();
    b.doOtherStuff();

What is the result?
    A) doSubStuff
    B) doOtherStuff
    C) doBaseStuff
    D) Exception at runtime
    E) Compilation failure

Q7) Given:
  class Base {
    void doBaseStuff() { System.out.println("doBaseStuff"); }
  }

class Sub extends Base {
    void doBaseStuff() { System.out.println("doSubStuff"); }
    void doOtherStuff() { System.out.println("doOtherStuff"); }
  }

    Base b = new Base();
    ((Sub)b).doOtherStuff();

What is the result?
    A) doSubStuff
    B) doOtherStuff
    C) doBaseStuff
    D) Exception at runtime
    E) Compilation failure

Q8) Given:
  class Base {
    void doBaseStuff() { System.out.println("doBaseStuff"); }
  }

class Sub extends Base {
    void doBaseStuff() { System.out.println("doSubStuff"); }
    void doOtherStuff() { System.out.println("doOtherStuff"); }
  }

    ((Sub)null).doOtherStuff();

What is the result?
    A) doSubStuff
    B) doOtherStuff
    C) doBaseStuff
    D) Exception at runtime
    E) Compilation failure

Q9) Given:
  class Base {
    void doBaseStuff() { System.out.println("doBaseStuff"); }
  }

class Sub {
    void doBaseStuff() { System.out.println("doSubStuff"); }
    void doOtherStuff() { System.out.println("doOtherStuff"); }
  }

    Base b = new Sub();
    ((Sub)b).doBaseStuff();

What is the result?
    A) doSubStuff
    B) doOtherStuff
    C) doBaseStuff
    D) Exception at runtime
    E) Compilation failure

Q10)
class Q22 {
    public int getValue() {return 1;}
}
which of these methods may individually be added
to a subclass of this class?

    A) public int getValue(int x) {return 1;}
    B) public String getValue() {return "Hello";}
    C) public String getValue(int x) {return "Hello";}
    D) A), B), and C)
    E) A), and C)

Q11)
  class Base {
    void doBaseStuff() {System.out.println("doBaseStuff");}
  }

  class Sub extends Base {
    void doBaseStuff() {System.out.println("doSubStuff");}
    void doOtherStuff() { System.out.println("doOtherStuff");}
  }

In the Base and Sub classes, which are true in isolation?
    A) doBaseStuff in Base can be marked public without causing errors
*   B) doBaseStuff in Base can be marked private without causing errors
*   C) doBaseStuff in Sub can be marked public without causing errors
*   D) doBaseStuff in Sub can be marked protected without causing errors
    E) doBaseStuff in Sub can be marked private without causing errors

Q12) Given:
class P {
  String name;
  P(String s) { this.name = s; } // line n1
}
class C extends P { // line n4
  @Override // line n2
  public String toString() { return "P with name " + name; }
}
and:
P p = new C(); // line n3
System.out.println(p);

What is the result:
A) Compilation fails at line n1
B) Compilation fails at line n2
C) Compilation fails at line n3
D) P with name null
E) Compilation fails at line n4
